<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#5B57D9">
    <title>SUDOKU</title>
    <link rel="manifest" href="manifest.json">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }


    body {
        font-family: 'Futura', 'Arial', sans-serif;
        background: #f5f5f7;
        user-select: none;
        overflow-y: scroll;
        height: 100vh;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
    }

    .screen {
        display: none;
        flex-direction: column;
        height: 100vh;
        width: 100%;
    }

    .screen.active {
        display: flex;
        flex-direction: column;
    }

    /* メニュー画面 */
    .menu-screen {
        padding: 10px 20px 20px 20px;
    }

    .logo {
        text-align: center;
        font-size: 48px;
        font-weight: 900;
        color: #5B57D9;
        margin: 10px 0 20px 0;
        letter-spacing: 4px;
    }

    .tab-buttons {
        display: flex;
        gap: 12px;
        margin-bottom: 30px;
    }

    .tab-btn {
        flex: 1;
        padding: 16px 24px;
        background: #E5E5EA;
        border: none;
        border-radius: 50px;
        font-size: 18px;
        font-weight: 600;
        color: #666;
        cursor: pointer;
        transition: all 0.3s;
        white-space: nowrap;
    }

    .tab-btn.active {
        background: #5B57D9;
        color: white;
        box-shadow: 0 4px 12px rgba(91, 87, 217, 0.3);
    }

    @media (max-width: 400px) {
        .tab-btn {
            font-size: 15px;
            padding: 14px 16px;
        }
    }

    .tab-content {
        display: none;
    }

    .tab-content.active {
        display: flex; /* ★ブロックではなくFlex Containerに変更 */
        flex-direction: column; /* ★これを追加して縦並びに戻します */
        flex: 1; /* ★親 (.menu-screen) の残りの高さを全て使うようにする */
    }

    .level-container {
        display: flex;
        flex-direction: column;
        flex: 1; /* ★ .menu-screen の残りのスペースを全て使用 */
        min-height: 250px
    }

    .level-buttons {
        display: flex;
        flex-direction: column;
        gap: 16px;
        padding-bottom: 20px;
        flex: 1;
    }

    .level-btn {
        flex: 1;
        flex-basis: 0;
        min-height: 50px;
        padding: 20px;
        background: #5B57D9;
        border: none;
        border-radius: 20px;
        color: white;
        font-size: 28px;
        font-weight: 700;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(91, 87, 217, 0.3);
        transition: transform 0.2s;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }


        .level-buttons {
            gap: 12px;
        }

        .level-btn {
            min-height: 70px;
            padding: 16px 12px;
            font-size: 24px;
        }

        .level-subtitle {
            font-size: 14px;
        }
    }

    .level-btn:active {
        transform: scale(0.98);
    }

    .level-subtitle {
        font-size: 16px;
        font-weight: 400;
        margin-top: 4px;
        opacity: 0.9;
    }

    /* 履歴 */
    .history-header {
        display: flex;
        justify-content: flex-end;
        margin-bottom: 12px;
    }

    .clear-all-btn {
        background: white;
        color: #FF3B30;
        border: 2px solid #FF3B30;
        border-radius: 25px;
        padding: 8px 16px;
        height: auto;
        width: auto;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-weight: 600;
        font-size: 14px;
        transition: all 0.2s;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .clear-all-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .clear-all-btn .material-icons {
        font-size: 20px;
    }

    .history-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .history-item {
        background: white;
        padding: 16px;
        border-radius: 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .history-info {
        flex: 1;
    }

    .history-main {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
    }

    .history-level {
        font-weight: 700;
        color: #5B57D9;
        font-size: 16px;
    }

    .history-time {
        color: #5B57D9;
        font-weight: 700;
        font-size: 16px;
        margin-left: 8px;
    }

    .history-date {
        color: #999;
        font-size: 12px;
    }

    .delete-btn {
        background: none;
        color: #FF3B30;
        border: none;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .delete-btn:hover {
        background-color: rgba(255, 59, 48, 0.1);
    }

    .empty-history {
        text-align: center;
        color: #999;
        padding: 40px;
        font-size: 16px;
    }

    /* カウントダウン画面 */
    .countdown-screen {
        background: #2C2C2E;
        justify-content: center;
        align-items: center;
    }

    .countdown-number {
        font-size: 120px;
        font-weight: 900;
        color: white;
        animation: countPulse 1s;
    }

    .countdown-level {
        color: white;
        font-size: 24px;
        margin-top: 20px;
        opacity: 0.8;
    }

    @keyframes countPulse {
        0% { transform: scale(0.5); opacity: 0; }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); opacity: 1; }
    }

    /* ゲーム画面 */
    .game-screen {
        background: #f5f5f7;
    }

    .game-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px;
        background: white;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .back-btn {
        background: #5B57D9;
        border: none;
        color: white;
        font-size: 20px;
        cursor: pointer;
        width: 44px;
        height: 44px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(91, 87, 217, 0.3);
    }

    .back-btn .material-icons {
        font-size: 24px;
    }

    .timer {
        font-size: 24px;
        font-weight: 700;
        color: #5B57D9;
    }

    .level-badge {
        background: #5B57D9;
        color: white;
        padding: 6px 12px;
        border-radius: 100px;
        font-size: 14px;
        font-weight: 600;
    }

    .game-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 28px;
        overflow-y: auto;
    }

    .game-container {
        width: 100%;
        max-width: 680px;
    }

    .board-container {
        width: 100%;
        margin-bottom: 16px;
    }

    .sudoku-board {
        background: white;
        border: 3px solid #2C2C2E;
        border-radius: 8px;
        box-shadow: 0 4px 16px rgba(0,0,0,0.15);
        width: 100%;
        padding-bottom: 100%;
        position: relative;
        overflow: hidden;
    }

    .board-grid {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: grid;
        grid-template-columns: repeat(9, 1fr);
        grid-template-rows: repeat(9, 1fr);
        width: 100%;
        height: 100%;
    }

    .cell {
        border: 0.5px solid #d0d0d0;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 22px;
        font-weight: 600;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
        cursor: pointer;
        position: relative;
        background: white;
    }

    .cell:nth-child(9n+3), .cell:nth-child(9n+6) {
        border-right: 2px solid #2C2C2E;
    }

    .cell:nth-child(n+19):nth-child(-n+27),
    .cell:nth-child(n+46):nth-child(-n+54) {
        border-bottom: 2px solid #2C2C2E;
    }

    .cell.fixed {
        color: #2C2C2E;
        font-weight: 700;
        background: #f8f8f8;
    }

    .cell.selected {
        background: #5B57D9 !important;
        color: white !important;
    }

    .cell.selected.memo-mode {
        background: #0288D1 !important;
    }

    .cell.selected .cell-note {
        color: white;
    }

    .cell.same-number {
        background: #E8E7FF !important;
    }

    .cell.same-number.memo-mode {
        background: #B4E5F5 !important;
    }

    .cell.error {
        background: #FFE5E5 !important;
        color: #FF3B30 !important;
    }

    .cell.related {
        background: #F0F0FF !important;
    }

    .cell.related.memo-mode {
        background: #E0F2F7 !important;
    }

    .cell-notes {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        width: 100%;
        height: 100%;
        color: #666;
        padding: 2px;
        position: absolute;
        top: 0;
        left: 0;
    }

    .cell-note {
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 8px;
    }

    /* 数字ボタン */
    .number-pad {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 8px;
        margin-bottom: 12px;
    }

    .number-btn {
        aspect-ratio: 1.6;
        background: #5B57D9;
        border: none;
        border-radius: 10px;
        color: white;
        font-size: 22px;
        font-weight: 700;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(91, 87, 217, 0.3);
        transition: transform 0.1s, background 0.3s;
    }

    .number-btn.memo-mode {
        background: #0288D1;
        box-shadow: 0 2px 8px rgba(2, 136, 209, 0.3);
    }

    .number-btn:active {
        transform: scale(0.95);
    }

    .number-btn.delete {
        background: #8E8E93;
    }

    /* 機能ボタン */
    .function-buttons {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin-bottom: 8px;
    }

    .function-buttons.top-row {
        grid-template-columns: repeat(3, 1fr);
        margin-bottom: 12px;
    }

    .function-btn {
        padding: 12px 8px;
        border: none;
        border-radius: 100px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        transition: transform 0.1s;
    }

    .function-btn .material-icons {
        font-size: 20px;
    }

    @media (max-width: 400px) {
        .function-btn {
            font-size: 13px;
            gap: 4px;
        }

        .function-btn .material-icons {
            font-size: 18px;
        }
    }

    .function-btn:active {
        transform: scale(0.98);
    }

    .function-btn.error-check {
        background: #FFE5E5; /* 薄い赤（背景ピンク） */
        color: #FF3B30;      /* 文字を赤 */
    }

    .function-btn.error-check.active {
        background: #E84045;
        color: white;
    }

    .function-btn.hint {
        background: #E5E5EA;
        color: #666;
    }

    .function-btn.pause {
        background: #E5E5EA;
        color: #666;
    }

    .function-btn.memo {
        background: #E5E5EA;
        color: #666;
    }

    .function-btn.memo.active {
        background: #0288D1;
        color: white;
    }

    .function-btn.reset {
        background: #E5E5EA;
        color: #666;
    }

    /* 一時停止オーバーレイ */
    .pause-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.9);
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }

    .pause-overlay.active {
        display: flex;
    }

    .pause-content {
        text-align: center;
        color: white;
    }

    .pause-title {
        font-size: 48px;
        font-weight: 700;
        margin-bottom: 30px;
    }

    .resume-btn {
        background: #5B57D9;
        color: white;
        border: none;
        padding: 16px 48px;
        border-radius: 100px;
        font-size: 20px;
        font-weight: 600;
        cursor: pointer;
    }

    /* 完成画面 */
    .complete-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.9);
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }

    .complete-overlay.active {
        display: flex;
    }

    .complete-content {
        background: white;
        padding: 40px;
        border-radius: 20px;
        text-align: center;
        max-width: 360px; 
        width: 90%; /* 画面幅の90%を使用（例） */
        box-sizing: border-box; /* paddingを含めて幅を計算 */
    }

    .complete-title {
        font-size: 32px;
        font-weight: 700;
        color: #5B57D9;
        margin-bottom: 20px;
    }

    .complete-time {
        font-size: 48px;
        font-weight: 700;
        color: #2C2C2E;
        margin-bottom: 30px;
    }

    .complete-buttons {
        display: flex;
        gap: 12px;
        flex-wrap: nowrap; 
        width: 100%; 
    }

    .complete-btn {
        flex: 1;
        padding: 16px;
        border: none;
        border-radius: 12px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        white-space: nowrap; 
    }

    .complete-btn.menu {
        background: #E5E5EA;
        color: #666;
    }

    .complete-btn.retry {
        background: #5B57D9;
        color: white;
    }

    @media (min-width: 768px) {
        .logo {
            font-size: 64px;
            margin: 50px 0;
        }

        .level-btn {
            font-size: 32px;
        }
        /* --- タブレット/大画面向け (例: 幅 768px 以上) --- */
@media (min-width: 768px) {

     .level-buttons {
        display: flex;
        flex-direction: column;
        gap: 20px;
        padding-bottom: 20px;
        flex: 1;
        overflow-y: auto;
    }

    .level-btn {
        flex: 1;
        flex-basis: 0;
        padding: 24px;
        color: white;
        font-size: 32px;
        font-weight: 700;
        display: flex;
    }

    .game-content {
       padding: 32px;
    
    /* 1. 数字ボタンのサイズとフォント調整 */
    .number-pad {
        gap: 12px; /* ボタン間の間隔を少し広げる */
    }

    .number-btn {
        font-size: 32px; /* 数字を大きく */
        border-radius: 16px; /* 角丸も少し大きく */
    }
    
    .cell {
        font-size: 30px;
    }
    .cell-note {
        font-size: 14px;
    }

    /* 2. 機能ボタンのサイズとフォント調整 */
    .function-buttons {
        gap: 12px; /* ボタン間の間隔を広げる */
    }
    
    .function-btn {
        padding: 16px 12px; /* パディングを増やし、ボタンの高さを増やす */
        font-size: 16px; /* テキストサイズを大きく */
    }

    .function-btn .material-icons {
        font-size: 24px; /* アイコンサイズを大きく */
    }
}


</style>

</head>
<body>
    <!-- メニュー画面 -->
    <div class="screen menu-screen active">
        <div class="logo">SUDOKU</div>
        <div class="tab-buttons">
            <button class="tab-btn active" data-tab="new-game">新しいゲーム</button>
            <button class="tab-btn" data-tab="history">履歴</button>
        </div>


    <div class="tab-content active" id="new-game-tab">
        <div class="level-buttons level-container">
            <button class="level-btn" data-level="beginner">
                入門
                <div class="level-subtitle">基本スキャンのみ</div>
            </button>
            <button class="level-btn" data-level="easy">
                初級
                <div class="level-subtitle">唯一候補法</div>
            </button>
            <button class="level-btn" data-level="medium">
                中級
                <div class="level-subtitle">ペア削除が必要</div>
            </button>
            <button class="level-btn" data-level="hard">
                上級
                <div class="level-subtitle">複数技法の組み合わせ</div>
            </button>
            <button class="level-btn" data-level="expert">
                達人
                <div class="level-subtitle">高度な論理推論</div>
            </button>
        </div>
    </div>
   
    <div class="tab-content" id="history-tab">
        <div class="history-header">
            <button class="clear-all-btn" id="clear-all-btn" style="display: none;">
                全件削除
            </button>
        </div>
        <div class="history-list" id="history-list"></div>
    </div>
</div>

<!-- カウントダウン画面 -->
<div class="screen countdown-screen">
    <div class="countdown-number" id="countdown-number">3</div>
    <div class="countdown-level" id="countdown-level"></div>
</div>

<!-- ゲーム画面 -->
<div class="screen game-screen">
    <div class="game-header">
        <button class="back-btn" id="back-btn"><span class="material-icons">arrow_back</span></button>
        <div class="timer" id="timer">0:00</div>
        <div class="level-badge" id="level-badge">入門</div>
    </div>
    
    <div class="game-content">
        <div class="game-container"> <div class="board-container">
                <div class="sudoku-board">
                    <div class="board-grid" id="board-grid"></div>
                </div>
            </div>
            
            <div class="controls"> <div class="number-pad">
                    <button class="number-btn" data-number="1">1</button>
                    <button class="number-btn" data-number="2">2</button>
                    <button class="number-btn" data-number="3">3</button>
                    <button class="number-btn" data-number="4">4</button>
                    <button class="number-btn" data-number="5">5</button>
                    <button class="number-btn" data-number="6">6</button>
                    <button class="number-btn" data-number="7">7</button>
                    <button class="number-btn" data-number="8">8</button>
                    <button class="number-btn" data-number="9">9</button>
                    <button class="number-btn delete" id="delete-btn">C</button>
                </div>
                
                <div class="function-buttons">
                    <button class="function-btn pause" id="pause-btn"><span class="material-icons">pause</span>一時停止</button>
                    <button class="function-btn memo" id="memo-btn"><span class="material-icons">edit_note</span>メモ</button>
                </div>
                
                <div class="function-buttons top-row">
                    <button class="function-btn error-check" id="error-check-btn"><span class="material-icons">error_outline</span>間違い表示</button>
                    <button class="function-btn hint" id="hint-btn"><span class="material-icons">lightbulb_outline</span>ヒント</button>
                    <button class="function-btn reset" id="reset-btn"><span class="material-icons">refresh</span>リセット</button>
                </div>
            </div> </div> </div>
</div>
<!-- 一時停止オーバーレイ -->
<div class="pause-overlay" id="pause-overlay">
    <div class="pause-content">
        <div class="pause-title">一時停止中</div>
        <button class="resume-btn" id="resume-btn">再開</button>
    </div>
</div>

<!-- 完成オーバーレイ -->
<div class="complete-overlay" id="complete-overlay">
    <div class="complete-content">
        <div class="complete-title">完成！</div>
        <div class="complete-time" id="complete-time">0:00</div>
        <div class="complete-buttons">
            <button class="complete-btn menu" id="menu-btn">戻る</button>
            <button class="complete-btn retry" id="retry-btn">もう一度</button>
        </div>
    </div>
</div>

<script>
    // ゲーム状態管理
    const game = {
        board: [],
        solution: [],
        initial: [],
        level: '',
        levelName: '',
        selectedCell: null,
        memoMode: false,
        errorCheckMode: false,
        startTime: null,
        elapsedTime: 0,
        timerInterval: null,
        isPaused: false
    };

    // 画面切り替え
    function showScreen(screenClass) {
        document.querySelectorAll('.screen').forEach(function(s) {
            s.classList.remove('active');
        });
        document.querySelector('.' + screenClass).classList.add('active');
    }

    // タブ切り替え
    document.querySelectorAll('.tab-btn').forEach(function(btn) {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.tab-btn').forEach(function(b) {
                b.classList.remove('active');
            });
            document.querySelectorAll('.tab-content').forEach(function(c) {
                c.classList.remove('active');
            });
            btn.classList.add('active');
            document.getElementById(btn.dataset.tab + '-tab').classList.add('active');
            if (btn.dataset.tab === 'history') {
                loadHistory();
            }
        });
    });

    // 数独生成の基本関数
    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }

    function isValid(board, row, col, num) {
        for (let x = 0; x < 9; x++) {
            if (board[row][x] === num) return false;
        }
        for (let x = 0; x < 9; x++) {
            if (board[x][col] === num) return false;
        }
        const startRow = Math.floor(row / 3) * 3;
        const startCol = Math.floor(col / 3) * 3;
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if (board[startRow + i][startCol + j] === num) return false;
            }
        }
        return true;
    }

    function fillBoard(board) {
        const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
       
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (board[row][col] === 0) {
                    shuffle(numbers);
                    for (let i = 0; i < numbers.length; i++) {
                        const num = numbers[i];
                        if (isValid(board, row, col, num)) {
                            board[row][col] = num;
                            if (fillBoard(board)) {
                                return true;
                            }
                            board[row][col] = 0;
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }

    // 簡易的な数独生成（動作確認用）
    function generateSudoku(level) {
        const board = [];
        for (let i = 0; i < 9; i++) {
            board[i] = [];
            for (let j = 0; j < 9; j++) {
                board[i][j] = 0;
            }
        }
       
        fillBoard(board);
        const solution = [];
        for (let i = 0; i < 9; i++) {
            solution[i] = board[i].slice();
        }
       
        // 段階的に穴を開けていく
        const puzzle = [];
        for (let i = 0; i < 9; i++) {
            puzzle[i] = solution[i].slice();
        }
       
        const cells = [];
        for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
                cells.push([r, c]);
            }
        }
        shuffle(cells);
       
        const targetHoles = {
            'beginner': 35,
            'easy': 40,
            'medium': 45,
            'hard': 50,
            'expert': 55
        };
       
        const maxHoles = targetHoles[level] || 35;
        let removed = 0;
       
        for (let i = 0; i < cells.length && removed < maxHoles; i++) {
            const r = cells[i][0];
            const c = cells[i][1];
            const backup = puzzle[r][c];
            puzzle[r][c] = 0;
           
            // 唯一解チェック
            if (hasUniqueSolution(puzzle, solution)) {
                removed++;
               
                // 難易度チェック
                const techniques = solvePuzzleWithTechniques(puzzle);
                if (isCorrectDifficulty(techniques, level)) {
                    return { board: puzzle, solution: solution };
                }
            } else {
                puzzle[r][c] = backup;
            }
        }
       
        return { board: puzzle, solution: solution };
    }

    // 唯一解チェック
    function hasUniqueSolution(puzzle, solution) {
        const test = [];
        for (let i = 0; i < 9; i++) {
            test[i] = puzzle[i].slice();
        }
       
        let solutionCount = 0;
       
        function countSolutions(board, limit) {
            if (solutionCount >= limit) return;
           
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (board[row][col] === 0) {
                        for (let num = 1; num <= 9; num++) {
                            if (isValid(board, row, col, num)) {
                                board[row][col] = num;
                                countSolutions(board, limit);
                                board[row][col] = 0;
                                if (solutionCount >= limit) return;
                            }
                        }
                        return;
                    }
                }
            }
            solutionCount++;
        }
       
        countSolutions(test, 2);
        return solutionCount === 1;
    }

    // 候補数の初期化
    function initCandidates(board) {
        const candidates = [];
        for (let r = 0; r < 9; r++) {
            candidates[r] = [];
            for (let c = 0; c < 9; c++) {
                candidates[r][c] = [];
                if (board[r][c] === 0) {
                    for (let num = 1; num <= 9; num++) {
                        if (isValid(board, r, c, num)) {
                            candidates[r][c].push(num);
                        }
                    }
                }
            }
        }
        return candidates;
    }

    // 候補数から数字を削除
    function eliminateCandidate(candidates, row, col, num) {
        // 行から削除
        for (let c = 0; c < 9; c++) {
            const index = candidates[row][c].indexOf(num);
            if (index !== -1) {
                candidates[row][c].splice(index, 1);
            }
        }
       
        // 列から削除
        for (let r = 0; r < 9; r++) {
            const index = candidates[r][col].indexOf(num);
            if (index !== -1) {
                candidates[r][col].splice(index, 1);
            }
        }
       
        // 3x3ブロックから削除
        const boxR = Math.floor(row / 3) * 3;
        const boxC = Math.floor(col / 3) * 3;
        for (let r = boxR; r < boxR + 3; r++) {
            for (let c = boxC; c < boxC + 3; c++) {
                const index = candidates[r][c].indexOf(num);
                if (index !== -1) {
                    candidates[r][c].splice(index, 1);
                }
            }
        }
    }

    // Naked Single（基本スキャン）
    function applyNakedSingles(board, candidates, techniques) {
        let found = false;
        for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
                if (board[r][c] === 0 && candidates[r][c].length === 1) {
                    const num = candidates[r][c][0];
                    board[r][c] = num;
                    candidates[r][c] = [];
                    eliminateCandidate(candidates, r, c, num);
                    techniques.nakedSingle++;
                    found = true;
                }
            }
        }
        return found;
    }

    // Hidden Single（唯一候補法）
    function applyHiddenSingles(board, candidates, techniques) {
        let found = false;
       
        // 行チェック
        for (let r = 0; r < 9; r++) {
            for (let num = 1; num <= 9; num++) {
                const positions = [];
                for (let c = 0; c < 9; c++) {
                    if (candidates[r][c].indexOf(num) !== -1) {
                        positions.push(c);
                    }
                }
                if (positions.length === 1) {
                    const c = positions[0];
                    if (board[r][c] === 0) {
                        board[r][c] = num;
                        candidates[r][c] = [];
                        eliminateCandidate(candidates, r, c, num);
                        techniques.hiddenSingle++;
                        found = true;
                    }
                }
            }
        }
       
        // 列チェック
        for (let c = 0; c < 9; c++) {
            for (let num = 1; num <= 9; num++) {
                const positions = [];
                for (let r = 0; r < 9; r++) {
                    if (candidates[r][c].indexOf(num) !== -1) {
                        positions.push(r);
                    }
                }
                if (positions.length === 1) {
                    const r = positions[0];
                    if (board[r][c] === 0) {
                        board[r][c] = num;
                        candidates[r][c] = [];
                        eliminateCandidate(candidates, r, c, num);
                        techniques.hiddenSingle++;
                        found = true;
                    }
                }
            }
        }
       
        // ブロックチェック
        for (let boxR = 0; boxR < 9; boxR += 3) {
            for (let boxC = 0; boxC < 9; boxC += 3) {
                for (let num = 1; num <= 9; num++) {
                    const positions = [];
                    for (let r = boxR; r < boxR + 3; r++) {
                        for (let c = boxC; c < boxC + 3; c++) {
                            if (candidates[r][c].indexOf(num) !== -1) {
                                positions.push([r, c]);
                            }
                        }
                    }
                    if (positions.length === 1) {
                        const r = positions[0][0];
                        const c = positions[0][1];
                        if (board[r][c] === 0) {
                            board[r][c] = num;
                            candidates[r][c] = [];
                            eliminateCandidate(candidates, r, c, num);
                            techniques.hiddenSingle++;
                            found = true;
                        }
                    }
                }
            }
        }
       
        return found;
    }

    // Naked Pairs（ペア削除）
    function applyNakedPairs(candidates, techniques) {
        let found = false;
       
        // 行チェック
        for (let r = 0; r < 9; r++) {
            const pairs = [];
            for (let c = 0; c < 9; c++) {
                if (candidates[r][c].length === 2) {
                    pairs.push({ col: c, nums: candidates[r][c].slice() });
                }
            }
           
            for (let i = 0; i < pairs.length - 1; i++) {
                for (let j = i + 1; j < pairs.length; j++) {
                    if (arraysEqual(pairs[i].nums, pairs[j].nums)) {
                        const pairNums = pairs[i].nums;
                        for (let c = 0; c < 9; c++) {
                            if (c !== pairs[i].col && c !== pairs[j].col) {
                                for (let k = 0; k < pairNums.length; k++) {
                                    const num = pairNums[k];
                                    const index = candidates[r][c].indexOf(num);
                                    if (index !== -1) {
                                        candidates[r][c].splice(index, 1);
                                        found = true;
                                    }
                                }
                            }
                        }
                        if (found) techniques.nakedPair++;
                    }
                }
            }
        }
       
        // 列チェック
        for (let c = 0; c < 9; c++) {
            const pairs = [];
            for (let r = 0; r < 9; r++) {
                if (candidates[r][c].length === 2) {
                    pairs.push({ row: r, nums: candidates[r][c].slice() });
                }
            }
           
            for (let i = 0; i < pairs.length - 1; i++) {
                for (let j = i + 1; j < pairs.length; j++) {
                    if (arraysEqual(pairs[i].nums, pairs[j].nums)) {
                        const pairNums = pairs[i].nums;
                        for (let r = 0; r < 9; r++) {
                            if (r !== pairs[i].row && r !== pairs[j].row) {
                                for (let k = 0; k < pairNums.length; k++) {
                                    const num = pairNums[k];
                                    const index = candidates[r][c].indexOf(num);
                                    if (index !== -1) {
                                        candidates[r][c].splice(index, 1);
                                        found = true;
                                    }
                                }
                            }
                        }
                        if (found) techniques.nakedPair++;
                    }
                }
            }
        }
       
        // ブロックチェック
        for (let boxR = 0; boxR < 9; boxR += 3) {
            for (let boxC = 0; boxC < 9; boxC += 3) {
                const pairs = [];
                for (let r = boxR; r < boxR + 3; r++) {
                    for (let c = boxC; c < boxC + 3; c++) {
                        if (candidates[r][c].length === 2) {
                            pairs.push({ row: r, col: c, nums: candidates[r][c].slice() });
                        }
                    }
                }
               
                for (let i = 0; i < pairs.length - 1; i++) {
                    for (let j = i + 1; j < pairs.length; j++) {
                        if (arraysEqual(pairs[i].nums, pairs[j].nums)) {
                            const pairNums = pairs[i].nums;
                            for (let r = boxR; r < boxR + 3; r++) {
                                for (let c = boxC; c < boxC + 3; c++) {
                                    if ((r !== pairs[i].row || c !== pairs[i].col) &&
                                        (r !== pairs[j].row || c !== pairs[j].col)) {
                                        for (let k = 0; k < pairNums.length; k++) {
                                            const num = pairNums[k];
                                            const index = candidates[r][c].indexOf(num);
                                            if (index !== -1) {
                                                candidates[r][c].splice(index, 1);
                                                found = true;
                                            }
                                        }
                                    }
                                }
                            }
                            if (found) techniques.nakedPair++;
                        }
                    }
                }
            }
        }
       
        return found;
    }

    // Hidden Pairs（隠れペア）
    function applyHiddenPairs(candidates, techniques) {
        let found = false;
       
        // 行チェック
        for (let r = 0; r < 9; r++) {
            for (let n1 = 1; n1 <= 8; n1++) {
                for (let n2 = n1 + 1; n2 <= 9; n2++) {
                    const positions = [];
                    for (let c = 0; c < 9; c++) {
                        if (candidates[r][c].indexOf(n1) !== -1 ||
                            candidates[r][c].indexOf(n2) !== -1) {
                            positions.push(c);
                        }
                    }
                   
                    if (positions.length === 2) {
                        const c1 = positions[0];
                        const c2 = positions[1];
                        if (candidates[r][c1].indexOf(n1) !== -1 &&
                            candidates[r][c1].indexOf(n2) !== -1 &&
                            candidates[r][c2].indexOf(n1) !== -1 &&
                            candidates[r][c2].indexOf(n2) !== -1) {
                           
                            if (candidates[r][c1].length > 2) {
                                candidates[r][c1] = [n1, n2];
                                found = true;
                            }
                            if (candidates[r][c2].length > 2) {
                                candidates[r][c2] = [n1, n2];
                                found = true;
                            }
                            if (found) techniques.hiddenPair++;
                        }
                    }
                }
            }
        }
       
        return found;
    }

    // Pointing Pairs（指定ペア）
    function applyPointingPairs(candidates, techniques) {
        let found = false;
       
        // 各ブロックをチェック
        for (let boxR = 0; boxR < 9; boxR += 3) {
            for (let boxC = 0; boxC < 9; boxC += 3) {
                for (let num = 1; num <= 9; num++) {
                    const positions = [];
                    for (let r = boxR; r < boxR + 3; r++) {
                        for (let c = boxC; c < boxC + 3; c++) {
                            if (candidates[r][c].indexOf(num) !== -1) {
                                positions.push([r, c]);
                            }
                        }
                    }
                   
                    if (positions.length >= 2 && positions.length <= 3) {
                        // 同じ行に揃っているか
                        const rows = [];
                        for (let i = 0; i < positions.length; i++) {
                            if (rows.indexOf(positions[i][0]) === -1) {
                                rows.push(positions[i][0]);
                            }
                        }
                       
                        if (rows.length === 1) {
                            const row = rows[0];
                            for (let c = 0; c < 9; c++) {
                                const inBox = c >= boxC && c < boxC + 3;
                                if (!inBox) {
                                    const index = candidates[row][c].indexOf(num);
                                    if (index !== -1) {
                                        candidates[row][c].splice(index, 1);
                                        found = true;
                                    }
                                }
                            }
                            if (found) techniques.pointingPair++;
                        }
                       
                        // 同じ列に揃っているか
                        const cols = [];
                        for (let i = 0; i < positions.length; i++) {
                            if (cols.indexOf(positions[i][1]) === -1) {
                                cols.push(positions[i][1]);
                            }
                        }
                       
                        if (cols.length === 1) {
                            const col = cols[0];
                            for (let r = 0; r < 9; r++) {
                                const inBox = r >= boxR && r < boxR + 3;
                                if (!inBox) {
                                    const index = candidates[r][col].indexOf(num);
                                    if (index !== -1) {
                                        candidates[r][col].splice(index, 1);
                                        found = true;
                                    }
                                }
                            }
                            if (found) techniques.pointingPair++;
                        }
                    }
                }
            }
        }
       
        return found;
    }

    // Box/Line Reduction
    function applyBoxLineReduction(candidates, techniques) {
        let found = false;
       
        // 行から各ブロックへ
        for (let r = 0; r < 9; r++) {
            for (let num = 1; num <= 9; num++) {
                const positions = [];
                for (let c = 0; c < 9; c++) {
                    if (candidates[r][c].indexOf(num) !== -1) {
                        positions.push(c);
                    }
                }
               
                if (positions.length >= 2 && positions.length <= 3) {
                    const boxes = [];
                    for (let i = 0; i < positions.length; i++) {
                        const box = Math.floor(positions[i] / 3);
                        if (boxes.indexOf(box) === -1) {
                            boxes.push(box);
                        }
                    }
                   
                    if (boxes.length === 1) {
                        const boxC = boxes[0] * 3;
                        const boxR = Math.floor(r / 3) * 3;
                       
                        for (let br = boxR; br < boxR + 3; br++) {
                            if (br !== r) {
                                for (let bc = boxC; bc < boxC + 3; bc++) {
                                    const index = candidates[br][bc].indexOf(num);
                                    if (index !== -1) {
                                        candidates[br][bc].splice(index, 1);
                                        found = true;
                                    }
                                }
                            }
                        }
                        if (found) techniques.boxLine++;
                    }
                }
            }
        }
       
        // 列から各ブロックへ
        for (let c = 0; c < 9; c++) {
            for (let num = 1; num <= 9; num++) {
                const positions = [];
                for (let r = 0; r < 9; r++) {
                    if (candidates[r][c].indexOf(num) !== -1) {
                        positions.push(r);
                    }
                }
               
                if (positions.length >= 2 && positions.length <= 3) {
                    const boxes = [];
                    for (let i = 0; i < positions.length; i++) {
                        const box = Math.floor(positions[i] / 3);
                        if (boxes.indexOf(box) === -1) {
                            boxes.push(box);
                        }
                    }
                   
                    if (boxes.length === 1) {
                        const boxR = boxes[0] * 3;
                        const boxC = Math.floor(c / 3) * 3;
                       
                        for (let br = boxR; br < boxR + 3; br++) {
                            for (let bc = boxC; bc < boxC + 3; bc++) {
                                if (bc !== c) {
                                    const index = candidates[br][bc].indexOf(num);
                                    if (index !== -1) {
                                        candidates[br][bc].splice(index, 1);
                                        found = true;
                                    }
                                }
                            }
                        }
                        if (found) techniques.boxLine++;
                    }
                }
            }
        }
       
        return found;
    }

    // 配列比較ヘルパー
    function arraysEqual(arr1, arr2) {
        if (arr1.length !== arr2.length) return false;
        for (let i = 0; i < arr1.length; i++) {
            if (arr1[i] !== arr2[i]) return false;
        }
        return true;
    }

    // Naked Triples（トリプル削除）
    function applyNakedTriples(candidates, techniques) {
        let found = false;
       
        // 行チェック
        for (let r = 0; r < 9; r++) {
            const cells = [];
            for (let c = 0; c < 9; c++) {
                if (candidates[r][c].length === 2 || candidates[r][c].length === 3) {
                    cells.push({ col: c, nums: candidates[r][c].slice() });
                }
            }
           
            // 3つのセルの組み合わせをチェック
            for (let i = 0; i < cells.length - 2; i++) {
                for (let j = i + 1; j < cells.length - 1; j++) {
                    for (let k = j + 1; k < cells.length; k++) {
                        const allNums = [];
                        for (let n = 0; n < cells[i].nums.length; n++) {
                            if (allNums.indexOf(cells[i].nums[n]) === -1) {
                                allNums.push(cells[i].nums[n]);
                            }
                        }
                        for (let n = 0; n < cells[j].nums.length; n++) {
                            if (allNums.indexOf(cells[j].nums[n]) === -1) {
                                allNums.push(cells[j].nums[n]);
                            }
                        }
                        for (let n = 0; n < cells[k].nums.length; n++) {
                            if (allNums.indexOf(cells[k].nums[n]) === -1) {
                                allNums.push(cells[k].nums[n]);
                            }
                        }
                       
                        if (allNums.length === 3) {
                            // Naked Triple発見
                            for (let c = 0; c < 9; c++) {
                                if (c !== cells[i].col && c !== cells[j].col && c !== cells[k].col) {
                                    for (let n = 0; n < allNums.length; n++) {
                                        const num = allNums[n];
                                        const index = candidates[r][c].indexOf(num);
                                        if (index !== -1) {
                                            candidates[r][c].splice(index, 1);
                                            found = true;
                                        }
                                    }
                                }
                            }
                            if (found) techniques.nakedTriple++;
                        }
                    }
                }
            }
        }
       
        return found;
    }

    // X-Wing
    function applyXWing(candidates, techniques) {
        let found = false;
       
        for (let num = 1; num <= 9; num++) {
            // 行でX-Wingを探す
            const rowsWithTwo = [];
            for (let r = 0; r < 9; r++) {
                const cols = [];
                for (let c = 0; c < 9; c++) {
                    if (candidates[r][c].indexOf(num) !== -1) {
                        cols.push(c);
                    }
                }
                if (cols.length === 2) {
                    rowsWithTwo.push({ row: r, cols: cols });
                }
            }
           
            // 2つの行で同じ2列に候補がある場合
            for (let i = 0; i < rowsWithTwo.length - 1; i++) {
                for (let j = i + 1; j < rowsWithTwo.length; j++) {
                    const cols1 = rowsWithTwo[i].cols;
                    const cols2 = rowsWithTwo[j].cols;
                   
                    if (cols1[0] === cols2[0] && cols1[1] === cols2[1]) {
                        // X-Wing発見！
                        for (let r = 0; r < 9; r++) {
                            if (r !== rowsWithTwo[i].row && r !== rowsWithTwo[j].row) {
                                const idx1 = candidates[r][cols1[0]].indexOf(num);
                                if (idx1 !== -1) {
                                    candidates[r][cols1[0]].splice(idx1, 1);
                                    found = true;
                                }
                                const idx2 = candidates[r][cols1[1]].indexOf(num);
                                if (idx2 !== -1) {
                                    candidates[r][cols1[1]].splice(idx2, 1);
                                    found = true;
                                }
                            }
                        }
                        if (found) techniques.xWing++;
                    }
                }
            }
           
            // 列でX-Wingを探す
            const colsWithTwo = [];
            for (let c = 0; c < 9; c++) {
                const rows = [];
                for (let r = 0; r < 9; r++) {
                    if (candidates[r][c].indexOf(num) !== -1) {
                        rows.push(r);
                    }
                }
                if (rows.length === 2) {
                    colsWithTwo.push({ col: c, rows: rows });
                }
            }
           
            for (let i = 0; i < colsWithTwo.length - 1; i++) {
                for (let j = i + 1; j < colsWithTwo.length; j++) {
                    const rows1 = colsWithTwo[i].rows;
                    const rows2 = colsWithTwo[j].rows;
                   
                    if (rows1[0] === rows2[0] && rows1[1] === rows2[1]) {
                        for (let c = 0; c < 9; c++) {
                            if (c !== colsWithTwo[i].col && c !== colsWithTwo[j].col) {
                                const idx1 = candidates[rows1[0]][c].indexOf(num);
                                if (idx1 !== -1) {
                                    candidates[rows1[0]][c].splice(idx1, 1);
                                    found = true;
                                }
                                const idx2 = candidates[rows1[1]][c].indexOf(num);
                                if (idx2 !== -1) {
                                    candidates[rows1[1]][c].splice(idx2, 1);
                                    found = true;
                                }
                            }
                        }
                        if (found) techniques.xWing++;
                    }
                }
            }
        }
       
        return found;
    }

    // XY-Wing
    function applyXYWing(candidates, techniques) {
        let found = false;
       
        // ピボットセル（2つの候補を持つセル）を探す
        for (let pr = 0; pr < 9; pr++) {
            for (let pc = 0; pc < 9; pc++) {
                if (candidates[pr][pc].length !== 2) continue;
               
                const pivotNums = candidates[pr][pc].slice();
                const X = pivotNums[0];
                const Y = pivotNums[1];
               
                // XZを持つウィング1を探す
                const wings1 = [];
                // 同じ行
                for (let c = 0; c < 9; c++) {
                    if (c !== pc && candidates[pr][c].length === 2) {
                        const nums = candidates[pr][c];
                        if (nums.indexOf(X) !== -1 && nums.indexOf(Y) === -1) {
                            const Z = nums[0] === X ? nums[1] : nums[0];
                            wings1.push({ r: pr, c: c, Z: Z });
                        }
                    }
                }
                // 同じ列
                for (let r = 0; r < 9; r++) {
                    if (r !== pr && candidates[r][pc].length === 2) {
                        const nums = candidates[r][pc];
                        if (nums.indexOf(X) !== -1 && nums.indexOf(Y) === -1) {
                            const Z = nums[0] === X ? nums[1] : nums[0];
                            wings1.push({ r: r, c: pc, Z: Z });
                        }
                    }
                }
                // 同じブロック
                const boxR = Math.floor(pr / 3) * 3;
                const boxC = Math.floor(pc / 3) * 3;
                for (let r = boxR; r < boxR + 3; r++) {
                    for (let c = boxC; c < boxC + 3; c++) {
                        if ((r !== pr || c !== pc) && candidates[r][c].length === 2) {
                            const nums = candidates[r][c];
                            if (nums.indexOf(X) !== -1 && nums.indexOf(Y) === -1) {
                                const Z = nums[0] === X ? nums[1] : nums[0];
                                wings1.push({ r: r, c: c, Z: Z });
                            }
                        }
                    }
                }
               
                // YZを持つウィング2を探す
                const wings2 = [];
                // 同じ行
                for (let c = 0; c < 9; c++) {
                    if (c !== pc && candidates[pr][c].length === 2) {
                        const nums = candidates[pr][c];
                        if (nums.indexOf(Y) !== -1 && nums.indexOf(X) === -1) {
                            const Z = nums[0] === Y ? nums[1] : nums[0];
                            wings2.push({ r: pr, c: c, Z: Z });
                        }
                    }
                }
                // 同じ列
                for (let r = 0; r < 9; r++) {
                    if (r !== pr && candidates[r][pc].length === 2) {
                        const nums = candidates[r][pc];
                        if (nums.indexOf(Y) !== -1 && nums.indexOf(X) === -1) {
                            const Z = nums[0] === Y ? nums[1] : nums[0];
                            wings2.push({ r: r, c: pc, Z: Z });
                        }
                    }
                }
                // 同じブロック
                for (let r = boxR; r < boxR + 3; r++) {
                    for (let c = boxC; c < boxC + 3; c++) {
                        if ((r !== pr || c !== pc) && candidates[r][c].length === 2) {
                            const nums = candidates[r][c];
                            if (nums.indexOf(Y) !== -1 && nums.indexOf(X) === -1) {
                                const Z = nums[0] === Y ? nums[1] : nums[0];
                                wings2.push({ r: r, c: c, Z: Z });
                            }
                        }
                    }
                }
               
                // ウィング1とウィング2で同じZを持つペアを探す
                for (let i = 0; i < wings1.length; i++) {
                    for (let j = 0; j < wings2.length; j++) {
                        if (wings1[i].Z === wings2[j].Z) {
                            const Z = wings1[i].Z;
                            // 両方のウィングから見えるセルからZを削除
                            for (let r = 0; r < 9; r++) {
                                for (let c = 0; c < 9; c++) {
                                    const seesWing1 = (r === wings1[i].r || c === wings1[i].c ||
                                        (Math.floor(r / 3) === Math.floor(wings1[i].r / 3) &&
                                         Math.floor(c / 3) === Math.floor(wings1[i].c / 3)));
                                    const seesWing2 = (r === wings2[j].r || c === wings2[j].c ||
                                        (Math.floor(r / 3) === Math.floor(wings2[j].r / 3) &&
                                         Math.floor(c / 3) === Math.floor(wings2[j].c / 3)));
                                   
                                    if (seesWing1 && seesWing2) {
                                        const index = candidates[r][c].indexOf(Z);
                                        if (index !== -1) {
                                            candidates[r][c].splice(index, 1);
                                            found = true;
                                        }
                                    }
                                }
                            }
                            if (found) techniques.xyWing++;
                        }
                    }
                }
            }
        }
       
        return found;
    }

    // 解法シミュレーター（更新版）
    function solvePuzzleWithTechniques(puzzle) {
        const techniques = {
            nakedSingle: 0,
            hiddenSingle: 0,
            nakedPair: 0,
            hiddenPair: 0,
            pointingPair: 0,
            boxLine: 0,
            nakedTriple: 0,
            xWing: 0,
            xyWing: 0
        };
       
        const working = [];
        for (let i = 0; i < 9; i++) {
            working[i] = puzzle[i].slice();
        }
       
        const candidates = initCandidates(working);
       
        let iterations = 0;
        const maxIterations = 300;
       
        while (iterations < maxIterations) {
            iterations++;
            let progress = false;
           
            // Naked Single
            if (applyNakedSingles(working, candidates, techniques)) {
                progress = true;
                continue;
            }
           
            // Hidden Single
            if (applyHiddenSingles(working, candidates, techniques)) {
                progress = true;
                continue;
            }
           
            // Naked Pairs
            if (applyNakedPairs(candidates, techniques)) {
                progress = true;
                continue;
            }
           
            // Hidden Pairs
            if (applyHiddenPairs(candidates, techniques)) {
                progress = true;
                continue;
            }
           
            // Pointing Pairs
            if (applyPointingPairs(candidates, techniques)) {
                progress = true;
                continue;
            }
           
            // Box/Line Reduction
            if (applyBoxLineReduction(candidates, techniques)) {
                progress = true;
                continue;
            }
           
            // Naked Triples
            if (applyNakedTriples(candidates, techniques)) {
                progress = true;
                continue;
            }
           
            // X-Wing
            if (applyXWing(candidates, techniques)) {
                progress = true;
                continue;
            }
           
            // XY-Wing
            if (applyXYWing(candidates, techniques)) {
                progress = true;
                continue;
            }
           
            if (!progress) break;
        }
       
        return techniques;
    }

    // 難易度判定（更新版）
    function isCorrectDifficulty(techniques, level) {
        const total = techniques.nakedSingle + techniques.hiddenSingle +
                     techniques.nakedPair + techniques.hiddenPair;
       
        switch(level) {
            case 'beginner':
                return techniques.nakedSingle >= 10 &&
                       techniques.hiddenSingle === 0 &&
                       techniques.nakedPair === 0;
                      
            case 'easy':
                return techniques.hiddenSingle >= 3 &&
                       techniques.nakedPair === 0 &&
                       techniques.hiddenPair === 0;
                      
            case 'medium':
                return techniques.hiddenSingle > 0 &&
                       (techniques.nakedPair >= 1 || techniques.hiddenPair >= 1) &&
                       techniques.pointingPair === 0 &&
                       techniques.boxLine === 0;
                      
            case 'hard':
                return (techniques.nakedPair >= 2 || techniques.hiddenPair >= 1) &&
                       (techniques.pointingPair >= 1 || techniques.boxLine >= 1) &&
                       techniques.nakedTriple === 0 &&
                       techniques.xWing === 0;
                      
            case 'expert':
                return (techniques.pointingPair >= 2 || techniques.boxLine >= 2) &&
                       (techniques.xWing >= 1 || techniques.nakedTriple >= 1 || techniques.xyWing >= 1);
                      
            default:
                return true;
        }
    }

    // レベル選択
    document.querySelectorAll('.level-btn').forEach(function(btn) {
        btn.addEventListener('click', function() {
            const level = btn.dataset.level;
            const levelNames = {
                'beginner': '入門',
                'easy': '初級',
                'medium': '中級',
                'hard': '上級',
                'expert': '達人'
            };
            game.level = level;
            game.levelName = levelNames[level];
            startCountdown();
        });
    });

    // カウントダウン
    function startCountdown() {
        showScreen('countdown-screen');
        document.getElementById('countdown-level').textContent = game.levelName;
        let count = 3;
        document.getElementById('countdown-number').textContent = count;
       
        const interval = setInterval(function() {
            count--;
            if (count > 0) {
                const el = document.getElementById('countdown-number');
                el.textContent = count;
                el.style.animation = 'none';
                setTimeout(function() {
                    el.style.animation = 'countPulse 1s';
                }, 10);
            } else {
                clearInterval(interval);
                startGame();
            }
        }, 1000);
    }

    // ゲーム開始
    function startGame() {
        const result = generateSudoku(game.level);
        game.board = [];
        for (let i = 0; i < 9; i++) {
            game.board[i] = result.board[i].slice();
        }
        game.solution = result.solution;
        game.initial = [];
        for (let i = 0; i < 9; i++) {
            game.initial[i] = result.board[i].slice();
        }
        game.selectedCell = null;
        game.memoMode = false;
        game.errorCheckMode = false;
        game.startTime = Date.now();
        game.elapsedTime = 0;
        game.isPaused = false;
       
        document.getElementById('level-badge').textContent = game.levelName;
        document.getElementById('memo-btn').classList.remove('active');
        document.getElementById('error-check-btn').classList.remove('active');
       
        // 数字ボタンのメモモードクラスも削除
        document.querySelectorAll('.number-btn[data-number]').forEach(function(btn) {
            btn.classList.remove('memo-mode');
        });
       
        renderBoard();
        showScreen('game-screen');
        startTimer();
    }

    // ボード描画
    function renderBoard() {
        const grid = document.getElementById('board-grid');
        grid.innerHTML = '';
       
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.row = row;
                cell.dataset.col = col;
               
                const value = game.board[row][col];
                if (game.initial[row][col] !== 0) {
                    cell.classList.add('fixed');
                    cell.textContent = value;
                } else if (value !== 0) {
                    if (typeof value === 'object') {
                        const notes = document.createElement('div');
                        notes.className = 'cell-notes';
                        for (let i = 1; i <= 9; i++) {
                            const note = document.createElement('div');
                            note.className = 'cell-note';
                            if (value.indexOf(i) !== -1) {
                                note.textContent = i;
                            }
                            notes.appendChild(note);
                        }
                        cell.appendChild(notes);
                    } else {
                        cell.textContent = value;
                        // 間違いチェックモードの場合、間違いをハイライト
                        if (game.errorCheckMode && value !== game.solution[row][col]) {
                            cell.classList.add('error');
                        }
                    }
                }
               
                cell.addEventListener('click', (function(r, c) {
                    return function() {
                        selectCell(r, c);
                    };
                })(row, col));
                grid.appendChild(cell);
            }
        }
       
        updateCellHighlights();
    }

    // セル選択
    function selectCell(row, col) {
        if (game.initial[row][col] !== 0) return;
        game.selectedCell = { row: row, col: col };
        updateCellHighlights();
    }

    // ハイライト更新
    function updateCellHighlights() {
        document.querySelectorAll('.cell').forEach(function(cell) {
            cell.classList.remove('selected', 'same-number', 'related', 'memo-mode');
        });
       
        if (!game.selectedCell) return;
       
        const row = game.selectedCell.row;
        const col = game.selectedCell.col;
        const selectedValue = game.board[row][col];
       
        document.querySelectorAll('.cell').forEach(function(cell) {
            const r = parseInt(cell.dataset.row);
            const c = parseInt(cell.dataset.col);
           
            if (game.memoMode) {
                cell.classList.add('memo-mode');
            }
           
            if (r === row && c === col) {
                cell.classList.add('selected');
            } else if (r === row || c === col ||
                      (Math.floor(r / 3) === Math.floor(row / 3) &&
                       Math.floor(c / 3) === Math.floor(col / 3))) {
                cell.classList.add('related');
            }
           
            if (selectedValue && typeof selectedValue === 'number' &&
                game.board[r][c] === selectedValue && !(r === row && c === col)) {
                cell.classList.add('same-number');
            }
        });
    }

    // 数字入力
    document.querySelectorAll('.number-btn[data-number]').forEach(function(btn) {
        btn.addEventListener('click', function() {
            if (!game.selectedCell || game.isPaused) return;
            const num = parseInt(btn.dataset.number);
            const row = game.selectedCell.row;
            const col = game.selectedCell.col;
           
            if (game.initial[row][col] !== 0) return;
           
            if (game.memoMode) {
                let notes = game.board[row][col];
                if (typeof notes !== 'object') {
                    notes = [];
                }
                const index = notes.indexOf(num);
                if (index !== -1) {
                    notes.splice(index, 1);
                } else {
                    notes.push(num);
                    notes.sort();
                }
                game.board[row][col] = notes.length > 0 ? notes : 0;
            } else {
                game.board[row][col] = num;
            }
           
            renderBoard();
            checkComplete();
        });
    });

    // 削除ボタン
    document.getElementById('delete-btn').addEventListener('click', function() {
        if (!game.selectedCell || game.isPaused) return;
        const row = game.selectedCell.row;
        const col = game.selectedCell.col;
        if (game.initial[row][col] === 0) {
            game.board[row][col] = 0;
            renderBoard();
        }
    });

    // メモモード切り替え
    document.getElementById('memo-btn').addEventListener('click', function() {
        game.memoMode = !game.memoMode;
        document.getElementById('memo-btn').classList.toggle('active');
       
        // 数字ボタンの色も変更
        document.querySelectorAll('.number-btn[data-number]').forEach(function(btn) {
            btn.classList.toggle('memo-mode');
        });
       
        // ハイライトカラーを即座に更新
        updateCellHighlights();
    });

    // 間違い表示（トグル式）
    document.getElementById('error-check-btn').addEventListener('click', function() {
        if (game.isPaused) return;
        game.errorCheckMode = !game.errorCheckMode;
        document.getElementById('error-check-btn').classList.toggle('active');
        renderBoard();
    });

    // ヒント
    document.getElementById('hint-btn').addEventListener('click', function() {
        if (!game.selectedCell || game.isPaused) return;
        const row = game.selectedCell.row;
        const col = game.selectedCell.col;
        if (game.initial[row][col] === 0) {
            game.board[row][col] = game.solution[row][col];
            renderBoard();
            checkComplete();
        }
    });

    // リセット
    document.getElementById('reset-btn').addEventListener('click', function() {
        if (game.isPaused) return;
        if (confirm('ボードをリセットしますか？')) {
            // ボードをリセット
            game.board = [];
            for (let i = 0; i < 9; i++) {
                game.board[i] = game.initial[i].slice();
            }
            game.selectedCell = null;
            
            // タイマーをリセット
            game.startTime = Date.now();
            game.elapsedTime = 0;
            updateTimerDisplay();
            
            // ボードを再描画
            renderBoard();
        }
    });

    // 一時停止
    document.getElementById('pause-btn').addEventListener('click', function() {
        pauseGame();
    });

    document.getElementById('resume-btn').addEventListener('click', function() {
        resumeGame();
    });

    function pauseGame() {
        if (game.isPaused) return;
        game.isPaused = true;
        clearInterval(game.timerInterval);
        // Calculate the time that has passed since the game started or was last resumed
        const currentTime = Date.now();
        const elapsedSinceStart = Math.floor((currentTime - game.startTime) / 1000);
        game.elapsedTime = elapsedSinceStart;
        document.getElementById('pause-overlay').classList.add('active');
    }

    function resumeGame() {
        if (!game.isPaused) return;
        game.isPaused = false;
        // Update the start time to now minus the elapsed time
        game.startTime = Date.now() - (game.elapsedTime * 1000);
        document.getElementById('pause-overlay').classList.remove('active');
        startTimer();
    }

    // タイマー
    function startTimer() {
        clearInterval(game.timerInterval);
        game.timerInterval = setInterval(function() {
            if (!game.isPaused) {
                game.elapsedTime = Math.floor((Date.now() - game.startTime) / 1000);
                updateTimerDisplay();
            }
        }, 1000);
    }

    function updateTimerDisplay() {
        const minutes = Math.floor(game.elapsedTime / 60);
        const seconds = game.elapsedTime % 60;
        const secStr = seconds < 10 ? '0' + seconds : seconds;
        document.getElementById('timer').textContent = minutes + ':' + secStr;
    }

    // 完成チェック
    function checkComplete() {
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                const value = game.board[row][col];
                if (!value || typeof value !== 'number' || value !== game.solution[row][col]) {
                    return;
                }
            }
        }
       
        clearInterval(game.timerInterval);
        saveHistory();
        showComplete();
    }

    function showComplete() {
        const minutes = Math.floor(game.elapsedTime / 60);
        const seconds = game.elapsedTime % 60;
        const secStr = seconds < 10 ? '0' + seconds : seconds;
        document.getElementById('complete-time').textContent = minutes + ':' + secStr;
        document.getElementById('complete-overlay').classList.add('active');
    }

    // 履歴保存
    function saveHistory() {
        const historyStr = localStorage.getItem('sudokuHistory') || '[]';
        const history = JSON.parse(historyStr);
        history.unshift({
            level: game.levelName,
            time: game.elapsedTime,
            date: new Date().toISOString()
        });
        localStorage.setItem('sudokuHistory', JSON.stringify(history));
    }

    // 履歴読み込み
    function loadHistory() {
        const historyStr = localStorage.getItem('sudokuHistory') || '[]';
        const history = JSON.parse(historyStr);
        const listEl = document.getElementById('history-list');
        const clearBtn = document.getElementById('clear-all-btn');
       
        if (history.length === 0) {
            listEl.innerHTML = '<div class="empty-history">履歴がありません</div>';
            clearBtn.style.display = 'none';
            return;
        }
       
        clearBtn.style.display = 'block';
        listEl.innerHTML = '';
       
        for (let i = 0; i < history.length; i++) {
            const item = history[i];
            const div = document.createElement('div');
            div.className = 'history-item';
           
            const minutes = Math.floor(item.time / 60);
            const seconds = item.time % 60;
            const secStr = seconds < 10 ? '0' + seconds : seconds;
            const date = new Date(item.date);
            const dateStr = (date.getMonth() + 1) + '/' + date.getDate() + ' ' +
                           date.getHours() + ':' + (date.getMinutes() < 10 ? '0' : '') + date.getMinutes();
           
            div.innerHTML =
                '<div class="history-info">' +
                    '<div class="history-main">' +
                        '<span class="history-level">' + item.level + ' <span class="history-time">' + minutes + ':' + secStr + '</span></span>' +
                    '</div>' +
                    '<div class="history-date">' + dateStr + '</div>' +
                '</div>' +
                '<button class="delete-btn" data-index="' + i + '" title="削除">' +
                    '<span class="material-icons">delete</span>' +
                '</button>';
           
            listEl.appendChild(div);
        }
       
        document.querySelectorAll('.delete-btn').forEach(function(btn) {
            btn.addEventListener('click', function() {
                const index = parseInt(btn.dataset.index);
                history.splice(index, 1);
                localStorage.setItem('sudokuHistory', JSON.stringify(history));
                loadHistory();
            });
        });
    }

    // 全件削除
    document.getElementById('clear-all-btn').addEventListener('click', function() {
        if (confirm('全ての履歴を削除しますか？')) {
            localStorage.setItem('sudokuHistory', '[]');
            loadHistory();
        }
    });

    // 完成後のボタン
    document.getElementById('menu-btn').addEventListener('click', function() {
        document.getElementById('complete-overlay').classList.remove('active');
        showScreen('menu-screen');
    });

    document.getElementById('retry-btn').addEventListener('click', function() {
        document.getElementById('complete-overlay').classList.remove('active');
        startCountdown();
    });

    // 戻るボタン
    document.getElementById('back-btn').addEventListener('click', function() {
        if (confirm('ゲームを終了しますか？')) {
            clearInterval(game.timerInterval);
            showScreen('menu-screen');
        }
    });

    // PWA対応
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', function() {
            navigator.serviceWorker.register('sw.js').catch(function() {});
        });
    }
</script>


</body>
</html>
